/*
Permission is hereby granted, free of charge, to any person or
organization obtaining a copy of the software and accompanying
documentation covered by this license (the “Software”) to use,
reproduce, display, distribute, execute, and transmit the Software,
and to prepare derivative works of the Software, and to permit
third-parties to whom the Software is furnished to do so, all subject
to the following:

The copyright notices in the Software and this entire statement,
including the above license grant, this restriction and the following
disclaimer, must be included in all copies of the Software, in whole
or in part, and all derivative works of the Software, unless such
copies or derivative works are solely in the form of
machine-executable object code generated by a source language
processor.

THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND
NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR ANYONE
DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER
LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT
OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <inttypes.h>

#include <mkc_macro.h>

#define likely(x)       __builtin_expect(!!(x), 1)
#define unlikely(x)     __builtin_expect(!!(x), 0)

//#define ALLOCATE_NODE malloc(NODE_SIZE)
#define ALLOCATE_NODE aligned_alloc(ALIGNMENT, NODE_SIZE)

#define COUNT_MASK (NODE_SIZE / sizeof(mkey_t) - 1)
#define TYPE_MASK (COUNT_MASK + 1u)

#define STATIC_ASSERT(NUM, COND) extern char __array__ ## NUM[((COND) != 0) - 1]

STATIC_ASSERT(0, sizeof(marika_error_t) == 16); // do not break ABI
STATIC_ASSERT(1, sizeof(leaf_node_t) == NODE_SIZE);
STATIC_ASSERT(2, sizeof(internal_node_t) == NODE_SIZE);
STATIC_ASSERT(3, (TYPE_MASK | COUNT_MASK) < ALIGNMENT);
STATIC_ASSERT(4, (TYPE_MASK & COUNT_MASK) == 0);

#define LEAF_DEGREE (sizeof(((leaf_node_t*)0)->keys) / sizeof(((leaf_node_t*)0)->keys[0]))
#define INTERNAL_DEGREE (sizeof(((internal_node_t*)0)->childs) / sizeof(((internal_node_t*)0)->childs[0]))

#ifdef mvalue_t
# define RETURN_VALUE_TYPE mvalue_t*
# define NOT_FOUND NULL
#else
# define RETURN_VALUE_TYPE int
# define NOT_FOUND 0
#endif

#define extract_ptr(ptr) (void*) (((uintptr_t) ptr) & ~(TYPE_MASK | COUNT_MASK))

static int extract_counter0(const void* ptr) {
	return ((uintptr_t) ptr) & COUNT_MASK;
}

static int extract_type(const void* ptr) {
	return ((uintptr_t) ptr) & TYPE_MASK;
}

#ifndef NO_PRINT
static void indent(unsigned depth) {
	for (unsigned k = 0; k < depth; ++k) {
		printf(" ");
	}
}

static void print_rec(FILE* fd, const void* top, unsigned depth) {
	unsigned type = extract_type(top);
	unsigned count0 = extract_counter0(top);
	if (!depth)
		fprintf(fd, "tree:\n");

	if (type) {
		const leaf_node_t* node = (const leaf_node_t*) extract_ptr(top);
		for (unsigned i = 0; i <= count0; ++i) {
			indent(depth);
#ifdef mvalue_t
			fprintf(fd, FMT_KEY_VALUE, node->keys[i], node->values[i]);
#else
			fprintf(fd, FMT_KEY, node->keys[i]);
#endif
		}
	} else {
		const internal_node_t* node = (const internal_node_t*) extract_ptr(top);
		for (unsigned i = 0; i <= count0; ++i) {
			if (i) {
				indent(depth);
				fprintf(fd, FMT_KEY, node->keys[i - 1]);
			}
			print_rec(fd, node->childs[i], depth + 3);
		}
	}

	if (!depth)
		fprintf(fd, "end tree\n\n");
}

void PRINT(FILE* fd, const void* top) {
	if (top)
		print_rec(fd, top, 0);
}
#endif

#ifndef NO_SEARCH
static RETURN_VALUE_TYPE leaf_search(const leaf_node_t* node, int count0, mkey_t key) {
	unsigned i = 0;

	int avg = (count0 + 1) / 2;
	if (! (key < node->keys[avg])) {
		i = avg;
	}

	for (; i <= count0; ++i) {
		mkey_t current_key = node->keys[i];
		if (current_key == key) {
#ifdef mvalue_t
			return __UNCONST(&node->values[i]);
#else
			return 1;
#endif
		} else if (current_key > key) {
			return 0;
		}
	}

	return 0;
}

static RETURN_VALUE_TYPE search_rec(const void* node, mkey_t key) {
	unsigned type = extract_type(node);
	unsigned count0 = extract_counter0(node);
	internal_node_t* inode = extract_ptr(node);
	if (type)
		return leaf_search((const leaf_node_t*) inode, count0, key);

	unsigned i = 0;

	int avg = (count0) / 2;
	if (! (key < inode->keys[avg])) {
		i = avg;
	}

	for (; i < count0; ++i) {
		mkey_t current_key = inode->keys[i];
		if (key < current_key)
			return search_rec(inode->childs[i], key);
	}

	return search_rec(inode->childs[i], key);
}

RETURN_VALUE_TYPE SEARCH(const void* node, mkey_t key) {
	if (node)
		return search_rec(node, key);
	else
		return NOT_FOUND;
}

#endif

#ifndef NO_FIRST
static RETURN_VALUE_TYPE leaf_first(const leaf_node_t* node, int count0, mkey_t* pkey) {
	mkey_t key = *pkey;
	for (unsigned i = 0; i <= count0; ++i) {
		mkey_t current_key = node->keys[i];
		if (current_key >= key) {
			*pkey = current_key;
#ifdef mvalue_t
			return __UNCONST(&node->values[i]);
#else
			return 1;
#endif
		}
	}

	return NOT_FOUND;
}

static RETURN_VALUE_TYPE first_rec(const void* node, mkey_t* pkey) {
	unsigned type = extract_type(node);
	unsigned count0 = extract_counter0(node);
	internal_node_t* inode = (internal_node_t*) extract_ptr(node);
	if (type)
		return leaf_first((const leaf_node_t*) inode, count0, pkey);

	unsigned i;
	mkey_t key = *pkey;
	for (i = 0; i < count0; ++i) {
		if (key < inode->keys[i]) {
			RETURN_VALUE_TYPE ret = first_rec(inode->childs[i], pkey);
			if (ret)
				return ret;
			else
				return first_rec(inode->childs[i + 1], pkey);
		}
	}

	return first_rec(inode->childs[i], pkey);
}

RETURN_VALUE_TYPE FIRST(const void* node, mkey_t* pkey) {
	if (node)
		return first_rec(node, pkey);
	else
		return NOT_FOUND;
}
#endif

#ifndef NO_NEXT
RETURN_VALUE_TYPE NEXT(const void* node, mkey_t* pkey) {
	if (!node)
		return NOT_FOUND;

	mkey_t new_key = *pkey;
	if (new_key == MAX_KEY)
		return NOT_FOUND;

	++new_key;
	RETURN_VALUE_TYPE ret = first_rec(node, &new_key);
	if (ret)
		*pkey = new_key;

	return ret;
}
#endif

#ifndef NO_LAST
static RETURN_VALUE_TYPE leaf_last(const leaf_node_t* node, int count0, mkey_t* pkey) {
	mkey_t key = *pkey;
	for (int i = count0; i >= 0; --i) {
		mkey_t current_key = node->keys[i];
		if (current_key <= key) {
			*pkey = current_key;
#ifdef mvalue_t
			return __UNCONST(&node->values[i]);
#else
			return 1;
#endif
		}
	}

	return NOT_FOUND;
}

static RETURN_VALUE_TYPE last_rec(const void* node, mkey_t* pkey) {
	unsigned type = extract_type(node);
	int count0 = extract_counter0(node);
	internal_node_t* inode = (internal_node_t*) extract_ptr(node);
	if (type)
		return leaf_last((leaf_node_t*) inode, count0, pkey);

	int i;
	mkey_t key = *pkey;
	for (i = count0 - 1; i >= 0; --i) {
		if (key >= inode->keys[i]) {
			RETURN_VALUE_TYPE ret = last_rec(inode->childs[i + 1], pkey);
			if (ret)
				return ret;
			else
				return last_rec(inode->childs[i], pkey);
		}
	}

	return last_rec(inode->childs[0], pkey);
}

RETURN_VALUE_TYPE LAST(const void* node, mkey_t* pkey) {
	if (node)
		return last_rec(node, pkey);
	else
		return NOT_FOUND;
}
#endif

#ifndef NO_PREV
RETURN_VALUE_TYPE PREV(const void* node, mkey_t* pkey) {
	if (!node)
		return NOT_FOUND;

	mkey_t new_key = *pkey;
	if (new_key == MIN_KEY)
		return NOT_FOUND;

	--new_key;
	RETURN_VALUE_TYPE ret = last_rec(node, &new_key);
	if (ret)
		*pkey = new_key;

	return ret;
}
#endif

#ifndef NO_INSERT

static void* make_leaf_ptr(void* ptr, unsigned count0) {
	return (void*) (((uintptr_t) ptr) | TYPE_MASK | count0);
}

static void* make_internal_ptr(void* ptr, unsigned count0) {
	return (void*) (((uintptr_t) ptr) | count0);
}

static __thread marika_error_t* lts_err;
#ifdef mvalue_t
static __thread mvalue_t* lts_value;
#endif

static leaf_node_t* leaf_split(leaf_node_t** pnode, leaf_node_t* node, int pos, mkey_t key, mkey_t* splitted_key) {
	leaf_node_t* ret = NULL;

	leaf_node_t* new_node = ALLOCATE_NODE;
	if (!new_node) {
		lts_err->errno = MARIKA_ERRNO_NOMEM;
		return 0;
	}

	unsigned half_offset = LEAF_DEGREE / 2;
	mkey_t first;
	if (pos < half_offset) {
		// right/splitted node
		int right_count0 = LEAF_DEGREE - half_offset - 1;
		for (int k = 0; k <= right_count0; ++k) {
			new_node->keys[k] = node->keys[half_offset + k];
		}
#ifdef mvalue_t
		for (int k = 0; k <= right_count0; ++k) {
			new_node->values[k] = node->values[half_offset + k];
		}
#endif
		ret = make_leaf_ptr(new_node, right_count0);

		// left/old node
		for (int k = half_offset; k > pos; --k) {
			node->keys[k] = node->keys[k - 1];
		}
#ifdef mvalue_t
		for (int k = half_offset; k > pos; --k) {
			node->values[k] = node->values[k - 1];
		}
#endif
		*pnode = make_leaf_ptr(node, half_offset);

		//
		node->keys[pos] = key;
#ifdef mvalue_t
		node->values[pos] = 0;
		lts_value = &node->values[pos];
#endif

		//
		first = node->keys[half_offset];
	} else {
		unsigned j;
		// left/old node
		*pnode = make_leaf_ptr(node, half_offset - 1);

		// right/splitted node
		int right_count0 = LEAF_DEGREE - half_offset;
		pos -= half_offset;
		for (j = 0; j < pos; ++j) {
			new_node->keys[j] = node->keys[half_offset + j];
		}
#ifdef mvalue_t
		for (int k = 0; k < pos; ++k) {
			new_node->values[k] = node->values[half_offset + k];
		}
#endif

		new_node->keys[j] = key;
#ifdef mvalue_t
		new_node->values[j] = 0;
		lts_value = &new_node->values[j];
#endif

		++j;
#ifdef mvalue_t
		for (int k = j; k <= right_count0; ++k) {
			new_node->values[k] = node->values[half_offset + k - 1];
		}
#endif
		for (; j <= right_count0; ++j) {
			new_node->keys[j] = node->keys[half_offset + j - 1];
		}

		ret = make_leaf_ptr(new_node, right_count0);

		//
		first = node->keys[half_offset - 1];
	}

	mkey_t last = new_node->keys[0];
	*splitted_key = first + (last - first + 1) / 2;

	return ret;
}

// returns 1 if new item was inserted, or 0 otherwise
static int leaf_insert(leaf_node_t** pnode, int count0, mkey_t key) {
	leaf_node_t* node = extract_ptr(*pnode);

	int pos = 0;

//	int avg = (count0 + 1) / 2;
//	if (! (key < node->keys[avg])) {
//		i = avg;
//	}

	for (; pos <= count0; ++pos) {
		mkey_t current_key = node->keys[pos];
		if (key < current_key)
			break;

		if (key == current_key) {
#ifdef mvalue_t
			lts_value = &node->values[pos];
#endif
			return 0;
		}
	}

	if (count0 < LEAF_DEGREE - 1) {
		for (int nc = count0; nc >= pos; --nc) {
			node->keys[nc + 1] = node->keys[nc];
#ifdef mvalue_t
			node->values[nc + 1] = node->values[nc];
#endif
		}
		node->keys[pos] = key;
#ifdef mvalue_t
		mvalue_t* ret_value = &node->values[pos];
		*ret_value = 0;
		lts_value = ret_value;
#endif

		++ *(char**)pnode;
		return 1;
	}

	return ~pos;
}

static void internal_insert(internal_node_t** pnode, mkey_t key, void* child) {
	internal_node_t* node = *pnode;
	int count0 = extract_counter0(node);
	node = (internal_node_t*) extract_ptr(node);

	int pos;
	for (pos = 0; pos < count0; ++pos) {
		mkey_t current_key = node->keys[pos];
		if (key < current_key)
			break;
	}

	if (count0 == INTERNAL_DEGREE - 1) {
		abort();
	}

	for (int nc = count0 - 1; nc >= pos; --nc) {
		node->keys[nc + 1] = node->keys[nc];
	}
	for (int nc = count0 + 1; nc > pos; --nc) {
		node->childs[nc + 1] = node->childs[nc];
	}
	node->keys[pos] = key;
	node->childs[pos + 1] = child;
	++ *(char**)pnode; // ++count0
}

static int insert_rec(void** pnode, mkey_t key, void** splited_node, mkey_t* splitted_key) {
	internal_node_t* inode = (internal_node_t*) *pnode;
	unsigned type = extract_type(inode);
	assert(!type);
	int count0 = extract_counter0(inode);

	inode = (internal_node_t*) extract_ptr(inode);
	int pos = 0;

//	int avg = (count0) / 2;
//	if (! (key < inode->keys[avg])) {
//		i = avg;
//	}

	for (; pos < count0; ++pos) {
		mkey_t current_key = inode->keys[pos];
		if (key < current_key)
			break;
	}

	void* new_node = NULL;
	mkey_t new_key = 0;

	void** pchild = &inode->childs[pos];
	int ret = 0;
	if (extract_type(*pchild)) {
		int pos2 = leaf_insert((leaf_node_t**) pchild, extract_counter0(*pchild), key);
		if (pos2 > 0) {
			return pos2;
		} else if (pos2 == 0) {
			return pos2;
		}

		pos2 = ~pos2;

		leaf_node_t* child = extract_ptr(*pchild);
		new_node = leaf_split((leaf_node_t**) pchild, child, pos2, key, &new_key);
	} else {
		ret = insert_rec(&inode->childs[pos], key, &new_node, &new_key);
	}

	if (ret || !new_node)
		return ret;

	if (count0 == INTERNAL_DEGREE - 1) {
		internal_node_t* new_node2 = ALLOCATE_NODE;
		if (!new_node2) {
			lts_err->errno = MARIKA_ERRNO_NOMEM;
			return 0;
		}
//		fprintf(stderr, "allocate -> %p\n", new_node2);
		unsigned half_offset = INTERNAL_DEGREE / 2;
		unsigned half_offset0 = half_offset - 1;
		unsigned half_count0 = count0 - half_offset;
		for (unsigned j = 0; j < half_count0; ++j) {
			new_node2->keys[j] = inode->keys[half_offset + j];
		}
		for (unsigned j = 0; j <= half_count0; ++j) {
			new_node2->childs[j] = inode->childs[half_offset + j];
		}
		*splited_node = make_internal_ptr(new_node2, half_count0);
		*splitted_key = inode->keys[half_offset0];
		*pnode = make_internal_ptr(inode, half_offset0);
		if (pos >= half_offset) {
			internal_insert((internal_node_t**) splited_node, new_key, new_node);
		} else {
			internal_insert((internal_node_t**) pnode, new_key, new_node);
		}
		return 0;
	}

	// move
	for (int nc = count0; nc > pos; --nc) {
		inode->keys[nc] = inode->keys[nc - 1];
	}
	for (int nc = count0; nc > pos; --nc) {
		inode->childs[nc + 1] = inode->childs[nc];
	}

	//
	inode->keys[pos] = new_key;
	++pos;
	inode->childs[pos] = new_node;
	++ *(char**)pnode; // ++count0

	return 1;
}

#ifdef mvalue_t
RETURN_VALUE_TYPE INSERT(void** pnode, mkey_t key, int* new_item, marika_error_t* err) {
#else
RETURN_VALUE_TYPE INSERT(void** pnode, mkey_t key, marika_error_t* err) {
#endif
	leaf_node_t* node = (leaf_node_t*) *pnode;
	if (unlikely(node == NULL)) {
		node = ALLOCATE_NODE;
		if (!node) {
			err->errno = MARIKA_ERRNO_NOMEM;
			return NOT_FOUND;
		}
//		fprintf(stderr, "allocate -> %p\n", node);
		node->keys[0] = key;
		*pnode = make_leaf_ptr(node, 0);
#ifdef mvalue_t
		mvalue_t* value = &node->values[0];
		*value = 0;
		*new_item = 1;
		return value;
#else
		return 1;
#endif
	}

	if (unlikely(extract_type(node))) {
//		printf("zzzzz\n");
//		node = extract_ptr(node);
		int pos = leaf_insert((leaf_node_t**) pnode, extract_counter0(node), key);
		if (pos >= 0) {
#ifdef mvalue_t
			*new_item = pos;
			return lts_value;
#else
			return pos;
#endif
		}

		pos = ~pos;

//		printf("yyyyy\n");
		node = extract_ptr(node);
		mkey_t splitted_key = 0;
		leaf_node_t* extra_node = leaf_split((leaf_node_t**) pnode, node, pos, key, &splitted_key);

		internal_node_t* top = ALLOCATE_NODE;
		if (!top) {
			err->errno = MARIKA_ERRNO_NOMEM;
			return NOT_FOUND;
		}

		top->keys[0] = splitted_key;
		top->childs[0] = *pnode;
		top->childs[1] = extra_node;
		top->size = LEAF_DEGREE + 1;

		*pnode = make_internal_ptr(top, 1);
#ifdef mvalue_t
		*new_item = 1;
		return lts_value;
#else
		return 1;
#endif
	}

	lts_err = err;
#ifdef mvalue_t
	lts_value = NULL;
#endif

	void* splited_node = NULL;
	mkey_t splitted_key;
	int ret = insert_rec(pnode, key, &splited_node, &splitted_key);
	if (likely(ret || !splited_node)) {
		if (ret && !extract_type(node)) {
			internal_node_t* top = extract_ptr(node);
			++top->size;
		}
#ifdef mvalue_t
		*new_item = ret;
		return lts_value;
#else
		return ret;
#endif
	}

	internal_node_t* top = ALLOCATE_NODE;
	if (unlikely(!top)) {
		free(splited_node); // lost data :'-(
		err->errno = MARIKA_ERRNO_NOMEM;
		return NOT_FOUND;
	}
//	fprintf(stderr, "allocate -> %p\n", top);

	top->keys[0] = splitted_key;
	top->childs[0] = *pnode;
	top->childs[1] = splited_node;

	*pnode = make_internal_ptr(top, 1);

	if (extract_type(node)) {
		top->size = LEAF_DEGREE + 1;
	} else {
		internal_node_t* inode = extract_ptr(node);
		top->size = inode->size + 1;
	}
#ifdef mvalue_t
	*new_item = 1;
	return lts_value;
#else
	return 1;
#endif
}
#endif // NO_INSERT

#ifndef NO_SANITY
static int sanity_check_rec(const void* _node, marika_error_t* err, mkey_t top_key, int less_than) {
	unsigned type = extract_type(_node);
	int count0 = extract_counter0(_node);
	if (type) {
		const leaf_node_t* node = (leaf_node_t*) extract_ptr(_node);
		mkey_t last_key = 0;
		for (int i = 0; i <= count0; ++i) {
			mkey_t key = node->keys[i];
			if (less_than == 0 || (less_than < 0 && key < top_key) || (less_than > 0 && !(key < top_key))) {
			} else {
				return MARIKA_ERRNO_BROKEN_TREE;
			}
			if (!i || last_key < key){
			} else {
				return MARIKA_ERRNO_BROKEN_TREE;
			}
			last_key = key;
		}
	} else {
		internal_node_t* node = (internal_node_t*) extract_ptr(_node);
		mkey_t last_key = 0;
		int ret = 0;
		for (int i = 0; i < count0; ++i) {
			mkey_t key = node->keys[i];
			ret = sanity_check_rec(node->childs[i], err, node->keys[i], -1);
			if (ret)
				return ret;
			if (i && ! (last_key < key))
				return MARIKA_ERRNO_BROKEN_TREE;

			last_key = key;
		}
		ret = sanity_check_rec(node->childs[count0], err, node->keys[count0 - 1], 1);
		if (ret)
			return ret;
	}

	return 0;
}

int SANITY(const void* top, marika_error_t* err) {
	if (!top)
		return 0;

	return sanity_check_rec(top, err, 0, 0);
}
#endif

#ifndef NO_FREE
void FREE_ARRAY(void** pnode) {
	unsigned type = extract_type(*pnode);
	if (type) {
		void* node = extract_ptr(*pnode);
//		fprintf(stderr, "free(%p)\n", node);
		free(node);
	} else {
		int count0 = extract_counter0(*pnode);
		internal_node_t* node = (internal_node_t*) extract_ptr(*pnode);
		if (!node)
			return;

		for (int i = 0; i <= count0; ++i) {
			FREE_ARRAY (&node->childs[i]);
		}

//		fprintf(stderr, "free(%p)\n", node);
		free(node);
	}
	*pnode = NULL;
}
#endif

#ifndef NO_SIZE
size_t SIZE(const void* top) {
	if (!top) {
		return 0;
	} else if (extract_type(top)) {
		return extract_counter0(top) + 1;
	} else {
		internal_node_t* top_node = extract_ptr(top);
		return top_node->size;
	}
}
#endif

#ifndef NO_MEMUSED
static size_t memused_rec(const void* _node) {
	unsigned type = extract_type(_node);
	int count0 = extract_counter0(_node);
	size_t ret = 0;

	if (!type) {
		internal_node_t* node = (internal_node_t*) extract_ptr(_node);
		for (int i = 0; i <= count0; ++i) {
			ret += memused_rec(node->childs[i]);
		}
	}
	ret += NODE_SIZE;

	return ret;
}

size_t MEMUSED(const void* top) {
	if (top)
		return memused_rec(top);
	else
		return 0;
}
#endif

#ifndef NO_COUNT
size_t COUNT(const void* top, mkey_t key1, mkey_t key2) {
	size_t count = 0;
	for (RETURN_VALUE_TYPE ret = FIRST(top, &key1); ret != 0 && key1 <= key2; ret = NEXT(top, &key1)) {
		++count;
	}
	return count;
}
#endif

#ifndef NO_ITERATE

static void leftmost_init(marika_iterator_t* iterator, const void* array, int start_depth) {
	const void* current = array;

	int depth = start_depth;
	while (!extract_type(current)) {
		internal_node_t* interal = (internal_node_t*)extract_ptr(current);
		iterator->key_nums[depth] = 0;
		iterator->key_counts0[depth] = extract_counter0(current);
		iterator->nodes[depth] = interal;
		current = interal->childs[0];
		++depth;
	}
	leaf_node_t* leaf = (leaf_node_t*)extract_ptr(current);
	iterator->key_nums[depth] = 0;
	iterator->key_counts0[depth] = extract_counter0(current);
	iterator->nodes[depth] = leaf;
}

void ITERATOR_INIT(const void* array, marika_iterator_t* iterator) {
	iterator->nodes = NULL;
	iterator->key_counts0 = NULL;
	iterator->key_nums = NULL;
	iterator->depth = 0;

	if (!array)
		return;

	// calculating depth
	const void* current = array;

	while (!extract_type(current)) {
		internal_node_t* interal = (internal_node_t*)extract_ptr(current);
		current = interal->childs[0];
		++iterator->depth;
	}
	++iterator->depth;

	// filling iterator members
	iterator->nodes = malloc(iterator->depth * sizeof(iterator->nodes[0]));
	iterator->key_counts0 = malloc(iterator->depth * sizeof(iterator->key_counts0[0]));
	iterator->key_nums = malloc(iterator->depth * sizeof(iterator->key_nums[0]));

	//
	leftmost_init(iterator, array, 0);
}

void ITERATOR_DESTROY(marika_iterator_t* iterator) {
	free(iterator->nodes);
	free(iterator->key_counts0);
	free(iterator->key_nums);
}

RETURN_VALUE_TYPE ITERATE(marika_iterator_t* iterator, mkey_t* index) {
	void** nodes = (void**) iterator->nodes;
	int depth = iterator->depth;

	do {
		int last = depth;
		int key_count0;
		int key_num;
		const leaf_node_t* node;
		int up = -1;
		do {
			--last;
			if (last < 0)
				return NOT_FOUND;

			key_count0 = iterator->key_counts0[last];
			key_num = iterator->key_nums[last]++;
			++up;
		} while(key_num > key_count0);

		node = nodes[last];
		if (!up) {
			*index = node->keys[key_num];
#ifdef mvalue_t
			return __UNCONST(&node->values[key_num]);
#else
			return 1;
#endif
		} else if (key_num != key_count0) {
			const internal_node_t* internal = ((const internal_node_t*) node)->childs[key_num + 1];
			leftmost_init(iterator, internal, last + 1);
		}
	}while(1);
}

#endif // NO_ITERATE
